package group_opt;

import com.opencsv.exceptions.CsvException;
import utils.CombinationFinder;
import utils.DataCSV;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.IntStream;

/**
 * The Group class represents a group of components with their associated scores,
 * loaded from a CSV file. It provides functionality to calculate optimal groupings
 * based on the average score between different combinations of components.
 * The class supports loading data from a CSV, calculating the optimal groups,
 * and printing formatted results.
 */
public class Group {

    private final List<String> components_name;
    private final List<List<Integer>> csv_data_score;
    private final List<List<Integer>> opt_groups;
    private double avg_group_score;

    private boolean print;

    //region Constructors
    /**
     * Default constructor initializes internal lists and sets the average group score to 0.
     */
    private Group(boolean print) {
        components_name = new ArrayList<>();
        csv_data_score = new ArrayList<>();
        opt_groups = new ArrayList<>();

        avg_group_score = 0;
        this.print = print;
    }

    /**
     * Constructs a Group object and loads data from a CSV file located at the specified path.
     * Optionally prints the loaded data if the 'print' parameter is set to true.
     *
     * @param path The file path of the CSV file to be loaded.
     * @param print A flag indicating whether the CSV data should be printed upon loading.
     * @throws IOException If an I/O error occurs while reading the CSV file.
     * @throws CsvException If an error occurs while parsing the CSV file.
     */
    public Group(String path, boolean print) throws IOException, CsvException {
        this(print);
        importData(DataCSV.loadCSVFile(path));
    }
    //endregion

    //region Public Method
    /**
     * Calculates the optimal groupings based on the average score between different combinations
     * of components. Combinations are generated by swapping elements between the first and
     * second halves of the list of components.
     *
     * @throws Exception If an error occurs during the combination generation process.
     */
    public void calculateOptGroups() throws Exception {
        List<Integer> init_comb = IntStream.rangeClosed(0, csv_data_score.getFirst().size() - 1).boxed().toList();
        List<List<Integer>> combinations = CombinationFinder.generateComb(init_comb);

        for (List<Integer> list : combinations) {
            double group_1 = calculateAvg(list.subList(0, list.size()/2 ));
            double group_2 = calculateAvg(list.subList(list.size()/2, list.size()));

            double groups_avg = (group_1 + group_2) / 2;

            if (print) {
                System.out.println(list);
                System.out.println(group_1 + ", " + group_2+ ", " + groups_avg);
            }

            if (groups_avg > avg_group_score) {
                opt_groups.clear();
                opt_groups.add(list);
                avg_group_score = groups_avg;
            } else if (groups_avg == avg_group_score) {
                opt_groups.add(list);
            }
        }
    }

    /**
     * Prints the content of the csv_data_score list formatted as a table, with each
     * value separated by a tab character.
     */
    public void printCsvDataScoreFormatted() {
        for (List<Integer> row : csv_data_score) {
            for (Integer value : row) {
                System.out.print(value + "\t");
            }
            System.out.println();
        }
    }

    /**
     * Prints the optimal group results, including the component names and the final score.
     */
    public void printFinalOptGroupFormatted() {
        System.out.println("\nFinal result: ");
        getOpt_groups_with_name().forEach(System.out::println);

        System.out.println("\nFinal score: " + getAvg_group_score());
    }

    public List<String> getComponents_name() {
        return components_name;
    }

    public List<List<Integer>> getCsv_data_score() {
        return csv_data_score;
    }

    public List<List<Integer>> getOpt_groups() {
        return opt_groups;
    }

    /**
     * Returns the optimal groupings with component names instead of indices.
     *
     * @return A list of lists of component names corresponding to the optimal groupings.
     */
    public List<List<String>> getOpt_groups_with_name() {
        List<List<String>> opt_g_w_n = new ArrayList<>();

        for (List<Integer> list: opt_groups) {
            List<String> l_str = new ArrayList<>();

            for (Integer i: list) {
                l_str.add(components_name.get(i));
            }

            opt_g_w_n.add(l_str);
        }

        return opt_g_w_n;
    }

    public double getAvg_group_score() {
        return avg_group_score;
    }

    //endregion

    //region Private Methods
    /**
     * Imports data from a list of string arrays (typically loaded from a CSV file) and populates two internal lists:
     * 1. [csv_data_score]: Populated with integer scores extracted from the imported data (starting from the second row).
     * 2. [components_name]: Populated with component names extracted from the first row of the imported data.
     *
     * @param imported_data A list of string arrays where each array represents a row of data from the CSV file.
     *                      The first row contains component names, and the following rows contain scores.
     */
    private void importData(List<String[]> imported_data) {
        int n = imported_data.size();

        /*
          Populate [csv_data_score] with integers loaded from CSV file
         */
        for (int i = 1; i <= n - 1; i++) {
            List<Integer> temp_list = new ArrayList<>();

            for (int j = 1; j <= n - 1; j++) {
                temp_list.add(Integer.parseInt(imported_data.get(i)[j]));
            }

            csv_data_score.add(temp_list);
        }


        /*
          Populate [components_name] with names loaded from CSV file
         */
        for (int i = 1; i < n; i++) {
            components_name.add(imported_data.getFirst()[i]);
        }

        if (print)  printCSV(imported_data);
    }

    /**
     * Prints the content of the imported CSV data to the console, formatting rows and columns accordingly.
     *
     * @param imported_data A list of string arrays representing the rows of data from the CSV file.
     */
    private void printCSV(List<String[]> imported_data) {
        AtomicInteger rowCounter = new AtomicInteger(0);
        imported_data.forEach(strings -> {
            if (rowCounter.getAndIncrement() == 0) {
                Arrays.stream(strings).toList().forEach(s -> {
                    System.out.print(s + "\t\t");
                });
            } else {
                Arrays.stream(strings).toList().forEach(s -> {
                    System.out.print(s + "\t\t\t");
                });
            }
            System.out.println();
        });
    }

    /**
     * Calculates the average score for a subset of components.
     *
     * @param values A list of integers representing the indices of components.
     * @return The average score for the specified subset of components.
     */
    private double calculateAvg (List<Integer> values) {
        int total = 0;

        for (int i=0; i<values.size(); i++) {
            for (int j=i+1; j<values.size(); j++) {
                total += csv_data_score.get(values.get(i)).get(values.get(j));
                total += csv_data_score.get(values.get(j)).get(values.get(i));
            }
        }

        return (double)total/values.size();
    }
    //endregion
}
